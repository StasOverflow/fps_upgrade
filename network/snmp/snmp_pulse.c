/*
Generated by LwipMibCompiler
*/

#include "lwip/apps/snmp_opts.h"
#if LWIP_SNMP

#include "snmp_pulse.h"
#include "lwip/apps/snmp.h"
#include "lwip/apps/snmp_core.h"
#include "lwip/apps/snmp_scalar.h"
#include "lwip/apps/snmp_table.h"


/* --- upsInput 4294967295.2.1.1 ----------------------------------------------------- */
static snmp_err_t upsinputtable_get_instance(const u32_t *column, const u32_t *row_oid, u8_t row_oid_len, struct snmp_node_instance *cell_instance);
static snmp_err_t upsinputtable_get_next_instance(const u32_t *column, struct snmp_obj_id *row_oid, struct snmp_node_instance *cell_instance);
static s16_t upsinputtable_get_value(struct snmp_node_instance *cell_instance, void *value);
static const struct snmp_table_col_def upsinputtable_columns[] = {
  {2, SNMP_ASN1_TYPE_OCTET_STRING, SNMP_NODE_INSTANCE_READ_ONLY}, /* upsInputName */ 
  {3, SNMP_ASN1_TYPE_INTEGER, SNMP_NODE_INSTANCE_READ_ONLY}, /* upsInputVoltage */ 
  {4, SNMP_ASN1_TYPE_INTEGER, SNMP_NODE_INSTANCE_READ_ONLY}, /* upsInputCurrent */ 
  {5, SNMP_ASN1_TYPE_INTEGER, SNMP_NODE_INSTANCE_READ_ONLY}, /* upsInputPower */ 
  {6, SNMP_ASN1_TYPE_INTEGER, SNMP_NODE_INSTANCE_READ_ONLY}, /* upsInputStatus */ 
};
static const struct snmp_table_node upsinputtable = SNMP_TABLE_CREATE(1, upsinputtable_columns, upsinputtable_get_instance, upsinputtable_get_next_instance, upsinputtable_get_value, NULL, NULL);

static const struct snmp_node *const upsinput_subnodes[] = {
  &upsinputtable.node.node
};
static const struct snmp_tree_node upsinput_treenode = SNMP_CREATE_TREE_NODE(1, upsinput_subnodes);

/* --- upsOutput 4294967295.2.1.3 ----------------------------------------------------- */
static snmp_err_t upsoutputtable_get_instance(const u32_t *column, const u32_t *row_oid, u8_t row_oid_len, struct snmp_node_instance *cell_instance);
static snmp_err_t upsoutputtable_get_next_instance(const u32_t *column, struct snmp_obj_id *row_oid, struct snmp_node_instance *cell_instance);
static s16_t upsoutputtable_get_value(struct snmp_node_instance *cell_instance, void *value);
static const struct snmp_table_col_def upsoutputtable_columns[] = {
  {2, SNMP_ASN1_TYPE_OCTET_STRING, SNMP_NODE_INSTANCE_READ_ONLY}, /* upsOutputName */ 
  {3, SNMP_ASN1_TYPE_INTEGER, SNMP_NODE_INSTANCE_READ_ONLY}, /* upsOutputVoltage */ 
  {4, SNMP_ASN1_TYPE_INTEGER, SNMP_NODE_INSTANCE_READ_ONLY}, /* upsOutputCurrent */ 
  {5, SNMP_ASN1_TYPE_INTEGER, SNMP_NODE_INSTANCE_READ_ONLY}, /* upsOutputPower */ 
  {6, SNMP_ASN1_TYPE_INTEGER, SNMP_NODE_INSTANCE_READ_ONLY}, /* upsOutputStatus */ 
};
static const struct snmp_table_node upsoutputtable = SNMP_TABLE_CREATE(1, upsoutputtable_columns, upsoutputtable_get_instance, upsoutputtable_get_next_instance, upsoutputtable_get_value, NULL, NULL);

static const struct snmp_node *const upsoutput_subnodes[] = {
  &upsoutputtable.node.node
};
static const struct snmp_tree_node upsoutput_treenode = SNMP_CREATE_TREE_NODE(3, upsoutput_subnodes);

/* --- ups 4294967295.2.1 ----------------------------------------------------- */
static s16_t upsbattery_scalars_get_value(const struct snmp_scalar_array_node_def *node, void *value);
static const struct snmp_scalar_array_node_def upsbattery_scalars_nodes[] = {
  {1, SNMP_ASN1_TYPE_INTEGER, SNMP_NODE_INSTANCE_READ_ONLY}, /* upsBatteryVoltage */ 
  {2, SNMP_ASN1_TYPE_INTEGER, SNMP_NODE_INSTANCE_READ_ONLY}, /* upsBatteryCurrent */ 
  {3, SNMP_ASN1_TYPE_INTEGER, SNMP_NODE_INSTANCE_READ_ONLY}, /* upsBatteryTemperature */ 
  {4, SNMP_ASN1_TYPE_INTEGER, SNMP_NODE_INSTANCE_READ_ONLY}, /* upsBatteryFullCapacity */ 
  {5, SNMP_ASN1_TYPE_INTEGER, SNMP_NODE_INSTANCE_READ_ONLY}, /* upsBatteryUsedCapacity */ 
  {6, SNMP_ASN1_TYPE_INTEGER, SNMP_NODE_INSTANCE_READ_ONLY}, /* upsBatteryStatus */ 
};
static const struct snmp_scalar_array_node upsbattery_scalars = SNMP_SCALAR_CREATE_ARRAY_NODE(2, upsbattery_scalars_nodes, upsbattery_scalars_get_value, NULL, NULL);

static s16_t upssystem_scalars_get_value(const struct snmp_scalar_array_node_def *node, void *value);
static const struct snmp_scalar_array_node_def upssystem_scalars_nodes[] = {
  {1, SNMP_ASN1_TYPE_INTEGER, SNMP_NODE_INSTANCE_READ_ONLY}, /* upsTemperature */ 
  {2, SNMP_ASN1_TYPE_INTEGER, SNMP_NODE_INSTANCE_READ_ONLY}, /* upsBypassState */ 
  {3, SNMP_ASN1_TYPE_INTEGER, SNMP_NODE_INSTANCE_READ_ONLY}, /* upsAlarmRelayState */ 
  {4, SNMP_ASN1_TYPE_INTEGER, SNMP_NODE_INSTANCE_READ_ONLY}, /* upsDischargeRelayState */ 
};
static const struct snmp_scalar_array_node upssystem_scalars = SNMP_SCALAR_CREATE_ARRAY_NODE(4, upssystem_scalars_nodes, upssystem_scalars_get_value, NULL, NULL);

static s16_t upssetup_scalars_get_value(const struct snmp_scalar_array_node_def *node, void *value);
static snmp_err_t upssetup_scalars_set_test(const struct snmp_scalar_array_node_def *node, u16_t len, void *value);
static snmp_err_t upssetup_scalars_set_value(const struct snmp_scalar_array_node_def *node, u16_t len, void *value);
static const struct snmp_scalar_array_node_def upssetup_scalars_nodes[] = {
  {1, SNMP_ASN1_TYPE_INTEGER, SNMP_NODE_INSTANCE_READ_WRITE}, /* upsBatteryFastVoltageSetup */ 
  {2, SNMP_ASN1_TYPE_INTEGER, SNMP_NODE_INSTANCE_READ_WRITE}, /* upsBatteryHoldVoltageSetup */ 
  {3, SNMP_ASN1_TYPE_INTEGER, SNMP_NODE_INSTANCE_READ_WRITE}, /* upsBatteryChargeCurrent */ 
  {4, SNMP_ASN1_TYPE_INTEGER, SNMP_NODE_INSTANCE_READ_WRITE}, /* upsBatteryTempCompSetup */ 
  {5, SNMP_ASN1_TYPE_INTEGER, SNMP_NODE_INSTANCE_READ_WRITE}, /* upsOutputVoltage1Setup */ 
  {6, SNMP_ASN1_TYPE_INTEGER, SNMP_NODE_INSTANCE_READ_WRITE}, /* upsOutputVoltage2Setup */ 
};
static const struct snmp_scalar_array_node upssetup_scalars = SNMP_SCALAR_CREATE_ARRAY_NODE(5, upssetup_scalars_nodes, upssetup_scalars_get_value, upssetup_scalars_set_test, upssetup_scalars_set_value);

static const struct snmp_node *const ups_subnodes[] = {
  &upsinput_treenode.node,
  &upsbattery_scalars.node.node,
  &upsoutput_treenode.node,
  &upssystem_scalars.node.node,
  &upssetup_scalars.node.node
};
static const struct snmp_tree_node ups_treenode = SNMP_CREATE_TREE_NODE(1, ups_subnodes);

/* --- pulse  ----------------------------------------------------- */
static const struct snmp_node *const pulse_subnodes[] = {
  &ups_treenode.node
};
static const struct snmp_tree_node pulse_root = SNMP_CREATE_TREE_NODE(2, pulse_subnodes);
static const u32_t pulse_base_oid[] = {4294967295,2};
const struct snmp_mib pulse = {pulse_base_oid, LWIP_ARRAYSIZE(pulse_base_oid), &pulse_root.node};



/*
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
LWIP MIB generator - preserved section begin
Code below is preserved on regeneration. Remove these comment lines to regenerate code.
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
*/

#include "input_property.h"
#include "psu_property.h"
#include "inverter_property.h"
#include "dc_output_property.h"
#include "ac_output_property.h"
#include "battery_property.h"
#include "ups_property.h"

/* --- upsInput 4294967295.2.1.1 ----------------------------------------------------- */
static const struct snmp_oid_range upsinputtable_oid_ranges[] =
{
	{ 1, INPUT_PHASE_COUNT }
};

static snmp_err_t upsinputtable_get_instance(const u32_t *column, const u32_t *row_oid, u8_t row_oid_len, struct snmp_node_instance *cell_instance)
{
   /*
   The instance OID of this table consists of following (index) column(s):
    upsInputIndex (Gauge, OID length = 1)
   */

   snmp_err_t err = SNMP_ERR_NOSUCHINSTANCE;

   if (row_oid_len == 1)
   {
      LWIP_UNUSED_ARG(column);
      LWIP_UNUSED_ARG(row_oid);
      LWIP_UNUSED_ARG(cell_instance);
      /*
      TODO: check if 'row_oid'/'row_oid_len' params contain a valid instance oid for a row
      If so, set 'err = SNMP_ERR_NOERROR;'
      
      snmp_oid_* methods may be used for easier processing of oid
      
      In order to avoid decoding OID a second time in subsequent get_value/set_test/set_value methods,
      you may store an arbitrary value (like a pointer to target value object) in 'cell_instance->reference'/'cell_instance->reference_len'.
      But be aware that not always a subsequent method is called -> Do NOT allocate memory here and try to release it in subsequent methods!
      
      You also may replace function pointers in 'cell_instance' param for get/test/set methods which contain the default values from table definition,
      in order to provide special methods, for the currently processed cell. Changed pointers are only valid for current request.
      */
      /* check if incoming OID length and if values are in plausible range */
      if (snmp_oid_in_range(row_oid, row_oid_len, upsinputtable_oid_ranges, LWIP_ARRAYSIZE(upsinputtable_oid_ranges)))
      {
    	  cell_instance->reference.u32 = row_oid[0];

    	  err = SNMP_ERR_NOERROR;
      }
   }

   return err;
}
static snmp_err_t upsinputtable_get_next_instance(const u32_t *column, struct snmp_obj_id *row_oid, struct snmp_node_instance *cell_instance)
{
   /*
   The instance OID of this table consists of following (index) column(s):
    upsInputIndex (Gauge, OID length = 1)
   */

   LWIP_UNUSED_ARG(column);
   LWIP_UNUSED_ARG(row_oid);
   LWIP_UNUSED_ARG(cell_instance);
   /*
   TODO: analyze 'row_oid->id'/'row_oid->len' and return the subsequent row instance
   Be aware that 'row_oid->id'/'row_oid->len' must not point to a valid instance or have correct instance length.
   If 'row_oid->len' is 0, return the first instance. If 'row_oid->len' is longer than expected, cut superfluous OID parts.
   If a valid next instance is found, store it in 'row_oid->id'/'row_oid->len' and set 'err = SNMP_ERR_NOERROR;'
   
   snmp_oid_* methods may be used for easier processing of oid
   
   In order to avoid decoding OID a second time in subsequent get_value/set_test/set_value methods,
   you may store an arbitrary value (like a pointer to target value object) in 'cell_instance->reference'/'cell_instance->reference_len'.
   But be aware that not always a subsequent method is called -> Do NOT allocate memory here and try to release it in subsequent methods!
   
   You also may replace function pointers in 'cell_instance' param for get/test/set methods which contain the default values from table definition,
   in order to provide special methods, for the currently processed cell. Changed pointers are only valid for current request.
   */
   /*
   For easier processing and getting the next instance, you may use the 'snmp_next_oid_*' enumerator.
   Simply pass all known instance OID's to it and it returns the next valid one:
   
   struct snmp_next_oid_state state;
   struct snmp_obj_id result_buf;
   snmp_next_oid_init(&state, row_oid->id, row_oid->len, result_buf, LWIP_SNMP_OBJ_ID_LEN);
   while ({not all instances passed}) {
     struct snmp_obj_id test_oid;
     {fill test_oid to create instance oid for next instance}
     snmp_next_oid_check(&state, test_oid->id, test_oid->len, {target_data_ptr});
   }
   if(state.status == SNMP_NEXT_OID_STATUS_SUCCESS) {
     snmp_oid_assign(row_oid, result_buf->oid, result_buf->len);
     cell_instance->reference.ptr = state.reference; //==target_data_ptr, for usage in subsequent get/test/set
     err = SNMP_ERR_NOERROR;
   }
   */
   struct snmp_next_oid_state state;
   u32_t result_temp[LWIP_ARRAYSIZE(upsinputtable_oid_ranges)];
   u32_t upsInputIndex;

   LWIP_UNUSED_ARG(column);

   /* init struct to search next oid */
   snmp_next_oid_init(&state, row_oid->id, row_oid->len, result_temp, LWIP_ARRAYSIZE(upsinputtable_oid_ranges));

   /* iterate over all possible OIDs to find the next one */
   upsInputIndex = 0;
   while (++upsInputIndex <= INPUT_PHASE_COUNT) {
     u32_t test_oid[LWIP_ARRAYSIZE(upsinputtable_oid_ranges)];
     test_oid[0] = upsInputIndex;

     /* check generated OID: is it a candidate for the next one? */
     snmp_next_oid_check(&state, test_oid, LWIP_ARRAYSIZE(upsinputtable_oid_ranges), (void *)upsInputIndex);
   }

   /* did we find a next one? */
   if (state.status == SNMP_NEXT_OID_STATUS_SUCCESS) {
     snmp_oid_assign(row_oid, state.next_oid, state.next_oid_len);
     /* store reference for subsequent operations (get/test/set) */
     cell_instance->reference.ptr = state.reference;
     return SNMP_ERR_NOERROR;
   }

   /* not found */
   return SNMP_ERR_NOSUCHINSTANCE;
}
static s16_t upsinputtable_get_value(struct snmp_node_instance *cell_instance, void *value)
{
   u8_t ph = cell_instance->reference.u32 - 1;
   s16_t value_len;

   static char *ph_names[INPUT_PHASE_COUNT] =
   {
	   "A",
	   "B",
	   "C",
	   "Bypass",
   };

   switch (SNMP_TABLE_GET_COLUMN_FROM_OID(cell_instance->instance_oid.id))
   {
      case 2:
         {
            /* upsInputName */
        	 char *v = (char *)value;

            /* TODO: take care that value with variable length fits into buffer: (value_len <= SNMP_MAX_VALUE_SIZE) */
            /* TODO: take care of len restrictions defined in MIB: ((value_len >= 0) && (value_len <= 255)) */
            /* TODO: put requested value to '*v' here */
            strcpy(v, ph_names[ph]);
            value_len = strlen(ph_names[ph]);
            LWIP_UNUSED_ARG(v);
         }
         break;
      case 3:
         {
            /* upsInputVoltage */
            u32_t *v = (u32_t *)value;

            /* TODO: put requested value to '*v' here */
            *v = InputPhasePropertyGet(ph, INPUT_VOLTAGE);
            value_len = sizeof(u32_t);
            LWIP_UNUSED_ARG(v);
         }
         break;
      case 4:
         {
            /* upsInputCurrent */
            u32_t *v = (u32_t *)value;

            /* TODO: put requested value to '*v' here */
            if( ph == 3 )
            {
            	if( UPSPropertyGet(SYSTEM_BYPASS_STATE) )
            	{
            		*v = InputPhasePropertyGet(ph, INPUT_CURRENT);
            	}
            	else
            	{
            		*v = 0;
            	}
            }

            value_len = sizeof(u32_t);
            LWIP_UNUSED_ARG(v);
         }
         break;
      case 5:
         {
            /* upsInputPower */
            u32_t *v = (u32_t *)value;

            /* TODO: put requested value to '*v' here */
            *v = InputPhasePropertyGet(ph, INPUT_POWER);
            value_len = sizeof(u32_t);
            LWIP_UNUSED_ARG(v);
         }
         break;
      case 6:
         {
            /* upsInputStatus */
            u32_t *v = (u32_t *)value;

            /* TODO: put requested value to '*v' here */
            *v = InputPhasePropertyGet(ph, INPUT_STATUS);
            value_len = sizeof(u32_t);
            LWIP_UNUSED_ARG(v);
         }
         break;
      default:
         {
            LWIP_DEBUGF(SNMP_MIB_DEBUG,("upsinputtable_get_value(): unknown id: %"S32_F"\n", SNMP_TABLE_GET_COLUMN_FROM_OID(cell_instance->instance_oid.id)));
            value_len = 0;
         }
         break;
   }
   return value_len;
}

/* --- upsOutput 4294967295.2.1.3 ----------------------------------------------------- */
static const struct snmp_oid_range upsoutputtable_oid_ranges[] =
{
	{ 1, OUTPUT_DC_COUNT }
};

static snmp_err_t upsoutputtable_get_instance(const u32_t *column, const u32_t *row_oid, u8_t row_oid_len, struct snmp_node_instance *cell_instance)
{
   /*
   The instance OID of this table consists of following (index) column(s):
    upsOutputIndex (Gauge, OID length = 1)
   */
   snmp_err_t err = SNMP_ERR_NOSUCHINSTANCE;

   if (row_oid_len == 1)
   {
      LWIP_UNUSED_ARG(column);
      LWIP_UNUSED_ARG(row_oid);
      LWIP_UNUSED_ARG(cell_instance);
      /*
      TODO: check if 'row_oid'/'row_oid_len' params contain a valid instance oid for a row
      If so, set 'err = SNMP_ERR_NOERROR;'
      
      snmp_oid_* methods may be used for easier processing of oid
      
      In order to avoid decoding OID a second time in subsequent get_value/set_test/set_value methods,
      you may store an arbitrary value (like a pointer to target value object) in 'cell_instance->reference'/'cell_instance->reference_len'.
      But be aware that not always a subsequent method is called -> Do NOT allocate memory here and try to release it in subsequent methods!
      
      You also may replace function pointers in 'cell_instance' param for get/test/set methods which contain the default values from table definition,
      in order to provide special methods, for the currently processed cell. Changed pointers are only valid for current request.
      */

      if (snmp_oid_in_range(row_oid, row_oid_len, upsoutputtable_oid_ranges, LWIP_ARRAYSIZE(upsoutputtable_oid_ranges)))
      {
    	  cell_instance->reference.u32 = row_oid[0];

    	  err = SNMP_ERR_NOERROR;
      }

   }
   return err;
}
static snmp_err_t upsoutputtable_get_next_instance(const u32_t *column, struct snmp_obj_id *row_oid, struct snmp_node_instance *cell_instance)
{
   /*
   The instance OID of this table consists of following (index) column(s):
    upsOutputIndex (Gauge, OID length = 1)
   */

   LWIP_UNUSED_ARG(column);
   LWIP_UNUSED_ARG(row_oid);
   LWIP_UNUSED_ARG(cell_instance);
   /*
   TODO: analyze 'row_oid->id'/'row_oid->len' and return the subsequent row instance
   Be aware that 'row_oid->id'/'row_oid->len' must not point to a valid instance or have correct instance length.
   If 'row_oid->len' is 0, return the first instance. If 'row_oid->len' is longer than expected, cut superfluous OID parts.
   If a valid next instance is found, store it in 'row_oid->id'/'row_oid->len' and set 'err = SNMP_ERR_NOERROR;'
   
   snmp_oid_* methods may be used for easier processing of oid
   
   In order to avoid decoding OID a second time in subsequent get_value/set_test/set_value methods,
   you may store an arbitrary value (like a pointer to target value object) in 'cell_instance->reference'/'cell_instance->reference_len'.
   But be aware that not always a subsequent method is called -> Do NOT allocate memory here and try to release it in subsequent methods!
   
   You also may replace function pointers in 'cell_instance' param for get/test/set methods which contain the default values from table definition,
   in order to provide special methods, for the currently processed cell. Changed pointers are only valid for current request.
   */
   /*
   For easier processing and getting the next instance, you may use the 'snmp_next_oid_*' enumerator.
   Simply pass all known instance OID's to it and it returns the next valid one:
   
   struct snmp_next_oid_state state;
   struct snmp_obj_id result_buf;
   snmp_next_oid_init(&state, row_oid->id, row_oid->len, result_buf, LWIP_SNMP_OBJ_ID_LEN);
   while ({not all instances passed}) {
     struct snmp_obj_id test_oid;
     {fill test_oid to create instance oid for next instance}
     snmp_next_oid_check(&state, test_oid->id, test_oid->len, {target_data_ptr});
   }
   if(state.status == SNMP_NEXT_OID_STATUS_SUCCESS) {
     snmp_oid_assign(row_oid, result_buf->oid, result_buf->len);
     cell_instance->reference.ptr = state.reference; //==target_data_ptr, for usage in subsequent get/test/set
     err = SNMP_ERR_NOERROR;
   }
   */
   struct snmp_next_oid_state state;
   u32_t result_temp[LWIP_ARRAYSIZE(upsoutputtable_oid_ranges)];
   u32_t upsOutputIndex;

   LWIP_UNUSED_ARG(column);

   /* init struct to search next oid */
   snmp_next_oid_init(&state, row_oid->id, row_oid->len, result_temp, LWIP_ARRAYSIZE(upsoutputtable_oid_ranges));

   /* iterate over all possible OIDs to find the next one */
   upsOutputIndex = 0;
   while (++upsOutputIndex <= OUTPUT_DC_COUNT) {
     u32_t test_oid[LWIP_ARRAYSIZE(upsoutputtable_oid_ranges)];
     test_oid[0] = upsOutputIndex;

     /* check generated OID: is it a candidate for the next one? */
     snmp_next_oid_check(&state, test_oid, LWIP_ARRAYSIZE(upsoutputtable_oid_ranges), (void *)upsOutputIndex);
   }

   /* did we find a next one? */
   if (state.status == SNMP_NEXT_OID_STATUS_SUCCESS) {
     snmp_oid_assign(row_oid, state.next_oid, state.next_oid_len);
     /* store reference for subsequent operations (get/test/set) */
     cell_instance->reference.ptr = state.reference;
     return SNMP_ERR_NOERROR;
   }

   /* not found */
   return SNMP_ERR_NOSUCHINSTANCE;
}
static s16_t upsoutputtable_get_value(struct snmp_node_instance *cell_instance, void *value)
{
	u8_t ch = cell_instance->reference.u32 - 1;
	s16_t value_len;

	static char *output_names[OUTPUT_DC_COUNT] =
	{
	   "+48V#1",
	   "+48V#2",
	   "+24V",
	   "+12V",
	};

   switch (SNMP_TABLE_GET_COLUMN_FROM_OID(cell_instance->instance_oid.id))
   {
      case 2:
         {
            /* upsOutputName */
            char *v = (char *)value;

            /* TODO: take care that value with variable length fits into buffer: (value_len <= SNMP_MAX_VALUE_SIZE) */
            /* TODO: take care of len restrictions defined in MIB: ((value_len >= 0) && (value_len <= 255)) */
            /* TODO: put requested value to '*v' here */
            strcpy(v, output_names[ch]);
            value_len = strlen(output_names[ch]);
            LWIP_UNUSED_ARG(v);
         }
         break;
      case 3:
         {
            /* upsOutputVoltage */
            u32_t *v = (u32_t *)value;

            /* TODO: put requested value to '*v' here */
            *v = DCOutputPropertyGet(ch, OUTPUT_DC_VOLTAGE);
            value_len = sizeof(u32_t);
            LWIP_UNUSED_ARG(v);
         }
         break;
      case 4:
         {
            /* upsOutputCurrent */
            u32_t *v = (u32_t *)value;

            /* TODO: put requested value to '*v' here */
            *v = DCOutputPropertyGet(ch, OUTPUT_DC_CURRENT);
            value_len = sizeof(u32_t);
            LWIP_UNUSED_ARG(v);
         }
         break;
      case 5:
         {
            /* upsOutputPower */
            u32_t *v = (u32_t *)value;

            /* TODO: put requested value to '*v' here */
            *v = DCOutputPropertyGet(ch, OUTPUT_DC_POWER);
            value_len = sizeof(u32_t);
            LWIP_UNUSED_ARG(v);
         }
         break;
      case 6:
         {
            /* upsOutputStatus */
            u32_t *v = (u32_t *)value;

            /* TODO: put requested value to '*v' here */
            *v = DCOutputPropertyGet(ch, OUTPUT_DC_STATUS);
            value_len = sizeof(u32_t);
            LWIP_UNUSED_ARG(v);
         }
         break;
      default:
         {
            LWIP_DEBUGF(SNMP_MIB_DEBUG,("upsoutputtable_get_value(): unknown id: %"S32_F"\n", SNMP_TABLE_GET_COLUMN_FROM_OID(cell_instance->instance_oid.id)));
            value_len = 0;
         }
         break;
   }
   return value_len;
}

/* --- ups 4294967295.2.1 ----------------------------------------------------- */
static s16_t upsbattery_scalars_get_value(const struct snmp_scalar_array_node_def *node, void *value)
{
   s16_t value_len;

   switch (node->oid)
   {
      case 1:
         {
            /* upsBatteryVoltage */
            u32_t *v = (u32_t *)value;

            /* TODO: put requested value to '*v' here */
            *v = BatteryPropertyGet(0, BATTERY_VOLTAGE);
            value_len = sizeof(u32_t);
            LWIP_UNUSED_ARG(v);
         }
         break;
      case 2:
         {
            /* upsBatteryCurrent */
            s32_t *v = (s32_t *)value;

            /* TODO: put requested value to '*v' here */
            *v = (s16_t)BatteryPropertyGet(0, BATTERY_CURRENT);
            value_len = sizeof(s32_t);
            LWIP_UNUSED_ARG(v);
         }
         break;
      case 3:
         {
            /* upsBatteryTemperature */
            s32_t *v = (s32_t *)value;

            /* TODO: put requested value to '*v' here */
            *v = (s16_t)BatteryPropertyGet(0, BATTERY_TEMPERATURE);
            value_len = sizeof(s32_t);
            LWIP_UNUSED_ARG(v);
         }
         break;
      case 4:
         {
            /* upsBatteryFullCapacity */
            u32_t *v = (u32_t *)value;

            /* TODO: put requested value to '*v' here */
            *v = BatteryPropertyGet(0, BATTERY_USED_CAPACITY);
            value_len = sizeof(u32_t);
            LWIP_UNUSED_ARG(v);
         }
         break;
      case 5:
         {
            /* upsBatteryUsedCapacity */
            u32_t *v = (u32_t *)value;

            /* TODO: put requested value to '*v' here */
            *v = BatteryPropertyGet(0, BATTERY_FULL_CAPACITY);
            value_len = sizeof(u32_t);
            LWIP_UNUSED_ARG(v);
         }
         break;
      case 6:
         {
            /* upsBatteryStatus */
            u32_t *v = (u32_t *)value;

            /* TODO: put requested value to '*v' here */
            *v = BatteryPropertyGet(0, BATTERY_STATUS);
            value_len = sizeof(u32_t);
            LWIP_UNUSED_ARG(v);
         }
         break;
      default:
         {
            LWIP_DEBUGF(SNMP_MIB_DEBUG,("upsbattery_scalars_get_value(): unknown id: %"S32_F"\n", node->oid));
            value_len = 0;
         }
         break;
   }
   return value_len;
}

static s16_t upssystem_scalars_get_value(const struct snmp_scalar_array_node_def *node, void *value)
{
   s16_t value_len;

   switch (node->oid)
   {
      case 1:
         {
            /* upsTemperature */
            s32_t *v = (s32_t *)value;

            /* TODO: put requested value to '*v' here */
            *v = UPSPropertyGet(SYSTEM_TEMPERATURE_EXTERNAL);
            value_len = sizeof(s32_t);
            LWIP_UNUSED_ARG(v);
         }
         break;
      case 2:
         {
            /* upsBypassState */
            s32_t *v = (s32_t *)value;

            /* TODO: put requested value to '*v' here */
            *v = UPSPropertyGet(SYSTEM_BYPASS_STATE);
            value_len = sizeof(s32_t);
            LWIP_UNUSED_ARG(v);
         }
         break;
      case 3:
         {
            /* upsAlarmRelayState */
            s32_t *v = (s32_t *)value;

            /* TODO: put requested value to '*v' here */
            *v = (UPSPropertyGet(SYSTEM_STATUS) == UPS_STATUS_ALARM) ? 1 : 0;
            value_len = sizeof(s32_t);
            LWIP_UNUSED_ARG(v);
         }
         break;
      case 4:
         {
            /* upsDischargeRelayState */
            s32_t *v = (s32_t *)value;

            /* TODO: put requested value to '*v' here */
            *v = ((signed short)BatteryPropertyGet(0, BATTERY_CURRENT) < 0) ? 1 : 0;
            value_len = sizeof(s32_t);
            LWIP_UNUSED_ARG(v);
         }
         break;
      default:
         {
            LWIP_DEBUGF(SNMP_MIB_DEBUG,("upssystem_scalars_get_value(): unknown id: %"S32_F"\n", node->oid));
            value_len = 0;
         }
         break;
   }
   return value_len;
}

static s16_t upssetup_scalars_get_value(const struct snmp_scalar_array_node_def *node, void *value)
{
   s16_t value_len;

   switch (node->oid)
   {
      case 1:
         {
            /* upsBatteryFastVoltageSetup */
            u32_t *v = (u32_t *)value;

            /* TODO: put requested value to '*v' here */
            *v = PSUGroupPropertyGet(0, PSU_GROUP_SETUP_VOLTAGE_FAST);
            value_len = sizeof(u32_t);
            LWIP_UNUSED_ARG(v);
         }
         break;
      case 2:
         {
            /* upsBatteryHoldVoltageSetup */
            u32_t *v = (u32_t *)value;

            /* TODO: put requested value to '*v' here */
            *v = PSUGroupPropertyGet(0, PSU_GROUP_SETUP_VOLTAGE_HOLD);
            value_len = sizeof(u32_t);
            LWIP_UNUSED_ARG(v);
         }
         break;
      case 3:
         {
            /* upsBatteryChargeCurrent */
            u32_t *v = (u32_t *)value;

            /* TODO: put requested value to '*v' here */
            *v = BatteryPropertyGet(0, BATTERY_CURRENT_LIMIT);
            value_len = sizeof(u32_t);
            LWIP_UNUSED_ARG(v);
         }
         break;
      case 4:
         {
            /* upsBatteryTempCompSetup */
            u32_t *v = (u32_t *)value;

            /* TODO: put requested value to '*v' here */
            *v = PSUGroupPropertyGet(0, PSU_GROUP_TEMPERATURE_COMPENSATION);
            value_len = sizeof(u32_t);
            LWIP_UNUSED_ARG(v);
         }
         break;
      case 5:
         {
            /* upsOutputVoltage1Setup */
            u32_t *v = (u32_t *)value;

            /* TODO: put requested value to '*v' here */
            *v = PSUGroupPropertyGet(1, PSU_GROUP_SETUP_VOLTAGE);
            value_len = sizeof(u32_t);
            LWIP_UNUSED_ARG(v);
         }
         break;
      case 6:
         {
            /* upsOutputVoltage2Setup */
            u32_t *v = (u32_t *)value;

            /* TODO: put requested value to '*v' here */
            *v = PSUGroupPropertyGet(2, PSU_GROUP_SETUP_VOLTAGE);
            value_len = sizeof(u32_t);
            LWIP_UNUSED_ARG(v);
         }
         break;
      default:
         {
            LWIP_DEBUGF(SNMP_MIB_DEBUG,("upssetup_scalars_get_value(): unknown id: %"S32_F"\n", node->oid));
            value_len = 0;
         }
         break;
   }
   return value_len;
}
static snmp_err_t upssetup_scalars_set_test(const struct snmp_scalar_array_node_def *node, u16_t len, void *value)
{
   snmp_err_t err = SNMP_ERR_WRONGVALUE;

   LWIP_UNUSED_ARG(value);
   LWIP_UNUSED_ARG(len);
   switch (node->oid)
   {
      case 1:
         {
            /* upsBatteryFastVoltageSetup */

            err = SNMP_ERR_NOERROR;
         }
         break;
      case 2:
         {
            /* upsBatteryHoldVoltageSetup */

            err = SNMP_ERR_NOERROR;
         }
         break;
      case 3:
         {
            /* upsBatteryChargeCurrent */

            err = SNMP_ERR_NOERROR;
         }
         break;
      case 4:
         {
            /* upsBatteryTempCompSetup */

            err = SNMP_ERR_NOERROR;
         }
         break;
      case 5:
         {
            /* upsOutputVoltage1Setup */

            err = SNMP_ERR_NOERROR;
         }
         break;
      case 6:
         {
            /* upsOutputVoltage2Setup */

            err = SNMP_ERR_NOERROR;
         }
         break;
      default:
         {
            LWIP_DEBUGF(SNMP_MIB_DEBUG,("upssetup_scalars_set_test(): unknown id: %"S32_F"\n", node->oid));
         }
         break;
   }
   return err;
}
static snmp_err_t upssetup_scalars_set_value(const struct snmp_scalar_array_node_def *node, u16_t len, void *value)
{
   snmp_err_t err = SNMP_ERR_NOERROR;

   LWIP_UNUSED_ARG(len);
   switch (node->oid)
   {
      case 1:
         {
            /* upsBatteryFastVoltageSetup */
            u32_t *v = (u32_t *)value;

            /* TODO: store new value contained in '*v' here */
            PSUGroupPropertySet(0, PSU_GROUP_SETUP_VOLTAGE_FAST, *v);
            LWIP_UNUSED_ARG(v);
         }
         break;
      case 2:
         {
            /* upsBatteryHoldVoltageSetup */
            u32_t *v = (u32_t *)value;

            /* TODO: store new value contained in '*v' here */
            PSUGroupPropertySet(0, PSU_GROUP_SETUP_VOLTAGE_HOLD, *v);
            LWIP_UNUSED_ARG(v);
         }
         break;
      case 3:
         {
            /* upsBatteryChargeCurrent */
            u32_t *v = (u32_t *)value;

            /* TODO: store new value contained in '*v' here */
            BatteryPropertySet(0, BATTERY_CURRENT_LIMIT, *v);
            LWIP_UNUSED_ARG(v);
         }
         break;
      case 4:
         {
            /* upsBatteryTempCompSetup */
            u32_t *v = (u32_t *)value;

            /* TODO: store new value contained in '*v' here */
            PSUGroupPropertySet(0, PSU_GROUP_TEMPERATURE_COMPENSATION, *v);
            LWIP_UNUSED_ARG(v);
         }
         break;
      case 5:
         {
            /* upsOutputVoltage1Setup */
            u32_t *v = (u32_t *)value;

            /* TODO: store new value contained in '*v' here */
            PSUGroupPropertySet(1, PSU_GROUP_SETUP_VOLTAGE, *v);
            LWIP_UNUSED_ARG(v);
         }
         break;
      case 6:
         {
            /* upsOutputVoltage2Setup */
            u32_t *v = (u32_t *)value;

            /* TODO: store new value contained in '*v' here */
            PSUGroupPropertySet(2, PSU_GROUP_SETUP_VOLTAGE, *v);
            LWIP_UNUSED_ARG(v);
         }
         break;
      default:
         {
            LWIP_DEBUGF(SNMP_MIB_DEBUG,("upssetup_scalars_set_value(): unknown id: %"S32_F"\n", node->oid));
         }
         break;
   }
   return err;
}

/* --- pulse  ----------------------------------------------------- */
#endif /* LWIP_SNMP */
